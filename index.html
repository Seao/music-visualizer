<!doctype html>
<html>
  <head>
    <title>music-visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="./lib/url.js"></script>
    <script src="./lib/jquery.js"></script>
    <script src="./lib/two.js"></script>
  </head>
  <body style="background: rgb(0, 128, 191);">
    <div class="scripts">
      <script>
        $(() => {

          const FREQUENCIES = {
            TOTAL: 128
          }

          const STAMP = {
            RADIUS: 150
          }

          const audioContext = new AudioContext()

          // request access to user microphone audio
          navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
              const input = audioContext.createMediaStreamSource(stream) // MediaStreamSourceNode
              const analyser = audioContext.createAnalyser() // AnalyserNode
              const scriptProcessor = audioContext.createScriptProcessor() // ScriptProcessorNode

              // set analyser configuration
              analyser.smoothingTimeConstant = 0.4
              analyser.fftSize = 256

              // connect the audio nodes
              input.connect(analyser)
              analyser.connect(scriptProcessor)
              scriptProcessor.connect(audioContext.destination)

              // create two instance
              const type = /(canvas|webgl)/.test(url.type) ? url.type : 'svg'
              const two = new Two({
                type: Two.Types[type],
                fullscreen: true
              }).appendTo(document.body)

              // instantiation of layers to manage overlays
              const background = two.makeGroup()
              const middleground = two.makeGroup()
              const foreground = two.makeGroup()

              /**
               * Creates the elements composing the stamp.
               */
              const createStamp = () => {
                const color = '#FFF'
                const stamp = two.makeGroup()
                const radius = STAMP.RADIUS
      
                // main stamp shape
                const core = two.makeCircle(0, 0, radius)
                core.noStroke()
                core.fill = color
                core.radius = radius

                stamp.core = core
                stamp.add(core)
      
                return stamp
              }

              /**
               * Affects a translational movement on the stamp to be centered on the screen.
               */
              const translateStamp = (stamp, points) => {
                stamp.translation.set(two.width / 2, two.height / 2)
              }

              /**
               * Creates the elements allowing to visualize frenquencies from audio input.
               */
              const createFrequencies = () => {
                const frequencies = []
                for (let i = 0; i < FREQUENCIES.TOTAL; i++) {
                  const line = two.makeLine(0, 0, 0, 0)
                  line.linewidth = 5
                  line.stroke = "rgba(0, 50, 255, 0.5)"

                  const frequency = two.makeGroup()
                  frequency.line = line
                  frequency.add(line)

                  frequencies.push(frequency)
                }
                return frequencies
              }

              /**
               * Affects a translational movement on the frequency points of the array. This method is
               * used to adjust the levels of each point according to the analyze of the audio stream.
               */
              const translateFrequencies = (frequencies, { level = 0, levels = [] } = {}) => {
                frequencies.forEach((frequency, i) => {
                  const radiusMin = STAMP.RADIUS
                  const radiusMax = radiusMin + (levels[i] || level)
                  const pct = (i + 1) / FREQUENCIES.TOTAL
                  const theta = pct * Math.PI * 2
                  const weight = 5

                  const minX = (radiusMin - weight) * Math.cos(theta)
                  const minY = (radiusMin - weight) * Math.sin(theta)
                  
                  const maxX = (radiusMax - weight) * Math.cos(theta)
                  const maxY = (radiusMax - weight) * Math.sin(theta)

                  const [start, finish] = frequency.line.vertices
                  start.set((two.width / 2) + minX, (two.height / 2) + minY)
                  finish.set((two.width / 2) + maxX, (two.height / 2) + maxY)
                })
              }

              // create and translate stamp
              const stamp = createStamp()
              translateStamp(stamp)

              // create and translate frequencies
              const frequencies = createFrequencies()
              translateFrequencies(frequencies)

              // add elements in layers
              background.add(frequencies)
              middleground.add(stamp)

              // event handler to process audio input
              scriptProcessor.onaudioprocess = (audioProcessingEvent) => {  
                // create a new Uint8Array to store the analyser's frequencyBinCount 
                const data = new Uint8Array(analyser.frequencyBinCount)

                // get the byte frequency data from our array
                analyser.getByteFrequencyData(data)

                translateFrequencies(frequencies, { levels: data })
              }

              // render the scene
              two
                .bind('resize', () => {
                  translateStamp(stamp)
                  translateFrequencies(frequencies)
                })
                .play()

            }, error => {
              // something went wrong, or the browser does not support getUserMedia
            })
        })
      </script>
    </div>
  </body>
</html>
